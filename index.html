<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quantum Portraits</title>
  <!-- Используем CDN для загрузки p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      color: #fff;
      font-family: 'Courier New', Courier, monospace;
      height: 100vh;
      overflow-y: auto;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .container {
      position: relative;
      width: 90%;
      max-width: 1200px;
      min-height: 100vh;
      padding: 20px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .step {
      display: none;
      flex-direction: column;
      align-items: center;
      width: 100%;
      flex-grow: 1;
    }
    .step.active {
      display: flex;
    }
    .text-container {
      width: 100%;
      padding: 10px;
      padding-top: 80px;
      word-wrap: break-word;
      text-align: center;
      margin-bottom: 20px;
      flex-shrink: 0;
    }
    .typewriter {
      font-size: 1.2rem;
      line-height: 1.5;
      white-space: pre-wrap;
    }
    .button-container {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      padding: 10px;
      flex-shrink: 0;
    }
    .button {
      padding: 10px 20px;
      background: none;
      border: 1px solid #fff;
      color: #fff;
      font-family: 'Courier New', Courier, monospace;
      cursor: pointer;
      transition: background 0.3s;
    }
    .button:hover, .button:focus {
      background: #333;
      outline: 2px solid #fff;
    }
    .button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .save-button {
      padding: 10px 20px;
      background: none;
      border: 1px solid #fff;
      color: #fff;
      font-family: 'Courier New', Courier, monospace;
      cursor: pointer;
      transition: background 0.3s;
      margin: 10px auto;
    }
    .save-button:hover, .save-button:focus {
      background: #333;
    }
    .back-button {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 10px 20px;
      background: none;
      border: 1px solid #fff;
      color: #fff;
      font-family: 'Courier New', Courier, monospace;
      cursor: pointer;
      transition: background 0.3s;
      z-index: 10;
    }
    .back-button:hover, .back-button:focus {
      background: #333;
    }
    .continue-button {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px 20px;
      background: none;
      border: 1px solid #fff;
      color: #fff;
      font-family: 'Courier New', Courier, monospace;
      cursor: pointer;
      transition: background 0.3s;
      z-index: 10;
    }
    .continue-button:hover, .continue-button:focus {
      background: #333;
    }
    canvas {
      display: none;
      border: 2px solid #fff;
      width: 100%;
      height: auto;
      max-height: calc(100vh - 250px);
      object-fit: contain;
      margin: 20px 0;
      z-index: 1;
      cursor: pointer;
    }
    #noiseOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0;
      background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABYSURBVGhD7c0hAQAgDAAx3L9tN4ZgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBg4D8P4wF1N8lKtwAAAABJRU5ErkJggg==');
      animation: noise 0.1s infinite;
    }
    @keyframes noise {
      0% { background-position: 0 0; }
      100% { background-position: 50px 50px; }
    }
    .flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #fff;
      opacity: 0;
      pointer-events: none;
    }
    .flash.active {
      animation: flash 0.3s;
    }
    @keyframes flash {
      0% { opacity: 0; }
      50% { opacity: 0.5; }
      100% { opacity: 0; }
    }
    #portraitGallery {
      display: none;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin: 20px 0;
      width: 100%;
    }
    .portrait {
      width: 100px;
      height: 100px;
      background: #333;
      cursor: pointer;
    }
    #authorsPage {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 20;
      padding: 20px;
      overflow-y: auto;
    }
    #loader {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 1.5rem;
      display: none;
    }

    /* Адаптивные стили */
    @media (max-width: 768px) {
      .text-container {
        font-size: 1rem;
        padding: 5px;
        padding-top: 120px;
      }
      .button-container {
        flex-direction: column;
        align-items: center;
      }
      .button, .save-button {
        width: 80%;
        margin: 5px 0;
      }
      canvas {
        max-height: calc(100vh - 300px);
      }
      .back-button, .continue-button {
        top: 10px;
        padding: 8px 15px;
      }
    }
    @media (max-width: 480px) {
      .text-container {
        font-size: 0.9rem;
        padding-top: 150px;
      }
      .portrait {
        width: 80px;
        height: 80px;
      }
      canvas {
        max-height: calc(100vh - 350px);
      }
    }
  </style>
</head>
<body>
  <div id="noiseOverlay"></div>
  <div class="flash" id="flashEffect"></div>
  <div id="loader">Загрузка...</div>
  <div class="container">
    <!-- Кнопка "Назад" -->
    <button class="back-button" id="backButton" style="display: none;" aria-label="Вернуться на предыдущий шаг" onclick="debouncedGoBack()">Назад / Back</button>
    <!-- Кнопка "Продолжить" -->
    <button class="continue-button" id="continueButton" style="display: none;" disabled aria-label="Перейти к следующему шагу" onclick="debouncedNextStep()">Продолжить / Continue</button>

    <!-- Шаг 0: Выбор языка -->
    <div class="step" id="step0">
      <div class="text-container">
        <div class="typewriter" id="typewriter0"></div>
      </div>
      <div class="button-container">
        <button class="button" aria-label="Выбрать русский язык" onclick="selectLanguage('ru')">RU</button>
        <button class="button" aria-label="Выбрать английский язык" onclick="selectLanguage('en')">ENG</button>
      </div>
    </div>

    <!-- Шаг 1: Приветствие -->
    <div class="step" id="step1">
      <div class="text-container">
        <div class="typewriter" id="typewriter1"></div>
      </div>
      <div class="button-container"></div>
    </div>

    <!-- Шаг 2: Загрузка портрета -->
    <div class="step" id="step2">
      <div class="text-container">
        <div class="typewriter" id="typewriter2"></div>
      </div>
      <div class="button-container" id="step2Buttons">
        <input type="file" id="imageInput" accept="image/*" style="display: none;">
        <button class="button" aria-label="Загрузить фото" onclick="document.getElementById('imageInput').click()">Загрузить фото / Upload Photo</button>
        <button class="button" aria-label="Выбрать из архива" onclick="openGallery()">Выбрать готовое / Select from Archive</button>
      </div>
    </div>

    <!-- Шаг 3: Инициализация -->
    <div class="step" id="step3">
      <div class="text-container">
        <div class="typewriter" id="typewriter3"></div>
      </div>
      <div class="button-container"></div>
    </div>

    <!-- Шаг 4: Наблюдение -->
    <div class="step" id="step4">
      <div class="text-container">
        <div class="typewriter" id="typewriter4"></div>
      </div>
      <div class="canvas-container" id="canvasContainer4"></div>
      <div class="button-container">
        <button class="button" aria-label="Перейти к следующему шагу" onclick="debouncedNextStep()">Продолжить / Continue</button>
      </div>
    </div>

    <!-- Шаг 5: Фиксация -->
    <div class="step" id="step5">
      <div class="text-container">
        <div class="typewriter" id="typewriter5"></div>
      </div>
      <button class="save-button" id="saveButton" style="display: none;" aria-label="Сохранить изображение" onclick="saveCurrentState()">Сохранить изображение / Save Image</button>
      <div class="canvas-container" id="canvasContainer5"></div>
      <div class="button-container">
        <button class="button" aria-label="Перейти к следующему шагу" onclick="debouncedNextStep()">Продолжить / Continue</button>
      </div>
    </div>

    <!-- Шаг 6: Интерпретация -->
    <div class="step" id="step6">
      <div class="text-container">
        <div class="typewriter" id="typewriter6"></div>
      </div>
      <div class="button-container">
        <button class="button" aria-label="Поделиться наблюдением" onclick="shareObservation()">ПОДЕЛИТЬСЯ НАБЛЮДЕНИЕМ / SHARE OBSERVATION</button>
      </div>
    </div>

    <!-- Шаг 7: Завершение -->
    <div class="step" id="step7">
      <div class="text-container">
        <div class="typewriter" id="typewriter7"></div>
      </div>
      <div class="button-container">
        <button class="button" aria-label="Начать заново" onclick="restart()">↻ НАЧАТЬ СНАЧАЛА / RESTART</button>
        <button class="button" aria-label="Перейти в архив" onclick="goToArchive()">⧉ ПЕРЕЙТИ В АРХИВ НАБЛЮДЕНИЙ / GO TO ARCHIVE</button>
        <button class="button" aria-label="О разработчиках" onclick="openAuthors()">ОБ АВТОРАХ / ABOUT US</button>
      </div>
    </div>

    <div id="portraitGallery"></div>
    <div id="authorsPage">
      <button class="button" aria-label="Закрыть страницу авторов" onclick="closeAuthors()">Закрыть / Close</button>
      <div class="text-container">
        <div class="typewriter">Слава Саша</div>
      </div>
    </div>
  </div>

  <script>
    let currentStep = 0;
    let language = 'ru';
    let img;
    let frame = 0;
    let isPaused = false;
    let particles = [];
    let quantumStates = [];
    let canvas;
    let isCanvasReady = false;

    const portraitUrls = [
      'https://via.placeholder.com/256?text=Portrait+1',
      'https://via.placeholder.com/256?text=Portrait+2',
      'https://via.placeholder.com/256?text=Portrait+3',
      'https://via.placeholder.com/256?text=Portrait+4',
      'https://via.placeholder.com/256?text=Portrait+5',
      'https://via.placeholder.com/256?text=Portrait+6',
      'https://via.placeholder.com/256?text=Portrait+7',
      'https://via.placeholder.com/256?text=Portrait+8',
      'https://via.placeholder.com/256?text=Portrait+9',
      'https://via.placeholder.com/256?text=Portrait+10'
    ];

    const translations = {
      step0: { ru: 'Пожалуйста, выберите язык\nPlease select a language', en: 'Пожалуйста, выберите язык\nPlease select a language' },
      step1: { ru: 'СТАТУС: НАБЛЮДАТЕЛЬ ПОДКЛЮЧЁН\n> Чему Шредингер может научить нас в области\nцифровой идентификации?\n> Добро пожаловать в экспериментальную зону.\n> Здесь наблюдение = вмешательство.', en: 'STATUS: OBSERVER CONNECTED\n> What can Schrödinger teach us about\ndigital identification?\n> Welcome to the experimental zone.\n> Here, observation = interference.' },
      step2: { ru: 'Шаг 1: Сканируйте лицо суперпозиции.\nВы можете загрузить изображение или выбрать вариант из архива.', en: 'Step 1: Scan the face of superposition.\nYou can upload an image or select from the archive.' },
      step2_after: { ru: '> Изображение принято.\n> Запускается волновая функция.\n> Система готова к инициализации.', en: '> Image accepted.\n> Wave function launching.\n> System ready for initialization.' },
      step3: { ru: 'Шаг 2: Инициализация\n> Изображение преобразовано в пиксельную\nсетку.\n> Каждому пикселю назначены параметры (x, y,\nbrightness, color).\n> На их основе построена волновая функция: ψ(x,\ny, t).\nУравнение эволюции:\niℏ ∂ψ/∂t = Ĥψ, где Ĥ = -½∇² + V(x, y)\n> Потенциал V(x, y) формируется из визуальных\nхарактеристик изображения.\n> Система переходит в режим временной\nсимуляции.\n> Портрет существует как совокупность\nвозможных состояний.', en: 'Step 2: Initialization\n> Image converted into a pixel grid.\n> Each pixel assigned parameters (x, y,\nbrightness, color).\n> Based on them, a wave function is built: ψ(x,\ny, t).\nEvolution equation:\niℏ ∂ψ/∂t = Ĥψ, where Ĥ = -½∇² + V(x, y)\n> Potential V(x, y) is formed from the visual\ncharacteristics of the image.\n> System enters temporal simulation mode.\n> The portrait exists as a set of possible\nstates.' },
      step4: { ru: 'Шаг 3: НАЧНИТЕ НАБЛЮДЕНИЕ\n> Двигайте курсором по изображению.\n> Каждый ваш жест запускает коллапс.\n> Система реагирует. Наблюдаемый образ\nформируется здесь и сейчас.', en: 'Step 3: BEGIN OBSERVATION\n> Move the cursor over the image.\n> Each gesture triggers a collapse.\n> The system reacts. The observed image is\nformed here and now.' },
      step5: { ru: 'Шаг 4: ФИКСАЦИЯ\n> Портрет — это процесс.\n> Но ты можешь зафиксировать один миг.\n> Это будет один из возможных тебя.', en: 'Step 4: FIXATION\n> A portrait is a process.\n> But you can fix a single moment.\n> This will be one of your possible selves.' },
      step6: { ru: 'Шаг 5: РЕАКЦИЯ СИСТЕМЫ\n> Это не портрет.\n> Это — реакция системы на тебя.\n> Ты повлиял на исход.', en: 'Step 5: SYSTEM REACTION\n> This is not a portrait.\n> This is the system\'s reaction to you.\n> You influenced the outcome.' },
      step7: { ru: 'Ты — не единственный наблюдатель.\nКаждое наблюдение — это акт, формирующий\nобраз. Здесь ты — одновременно субъект и\nобъект.', en: 'You are not the only observer.\nEach observation is an act that shapes the\nimage. Here, you are both subject and object.' }
    };

    // Debouncing для предотвращения множественных кликов
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    const debouncedNextStep = debounce(nextStep, 300);
    const debouncedGoBack = debounce(goBack, 300);

    function selectLanguage(lang) {
      language = lang;
      updateContinueButtonText();
      debouncedNextStep();
    }

    function showCanvas(containerId) {
      if (!canvas) {
        console.error(`Канва не создана для ${containerId}!`);
        return;
      }
      // Удаляем канву из текущего контейнера
      const canvasElement = canvas.elt;
      const currentParent = canvasElement.parentElement;
      if (currentParent) {
        currentParent.removeChild(canvasElement);
      }
      // Перемещаем канву в новый контейнер
      const container = document.getElementById(containerId);
      if (container) {
        container.appendChild(canvasElement);
        canvasElement.style.display = 'block';
        console.log(`Канва перемещена в ${containerId} и отображается`);
      } else {
        console.error(`Контейнер ${containerId} не найден!`);
      }
    }

    function hideCanvas() {
      if (canvas) {
        canvas.elt.style.display = 'none';
        console.log('Канва скрыта');
      }
    }

    function nextStep() {
      if (currentStep >= 7) return;

      if (currentStep >= 2 && !img) {
        alert(language === 'ru' ? 'Пожалуйста, загрузите фото или выберите из архива.' : 'Please upload a photo or select from the archive.');
        return;
      }

      const currentStepElement = document.querySelector(`#step${currentStep}`);
      if (currentStepElement) currentStepElement.classList.remove('active');

      currentStep++;
      const nextStepElement = document.querySelector(`#step${currentStep}`);
      if (!nextStepElement) {
        console.error(`Шаг ${currentStep} не найден!`);
        currentStep--;
        return;
      }

      nextStepElement.classList.add('active');
      document.getElementById('backButton').style.display = currentStep > 0 ? 'block' : 'none';
      document.getElementById('continueButton').style.display = currentStep > 0 && currentStep < 7 ? 'block' : 'none';
      updateContinueButtonState();

      if (currentStep === 1) {
        triggerFlash();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 50, () => setTimeout(debouncedNextStep, 10000));
      } else if (currentStep === 2) {
        hideCanvas();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 50);
      } else if (currentStep === 3) {
        if (!img) {
          debouncedGoBack();
          return;
        }
        triggerFlash();
        hideCanvas();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 50);
      } else if (currentStep === 4) {
        if (isCanvasReady) {
          showCanvas('canvasContainer4');
          loop();
        } else {
          console.error('Шаг 4: Канва не готова!');
          setTimeout(() => {
            if (isCanvasReady) {
              showCanvas('canvasContainer4');
              loop();
            }
          }, 500);
        }
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 50);
      } else if (currentStep === 5) {
        if (isCanvasReady) {
          showCanvas('canvasContainer5');
          if (!isPaused) loop();
        } else {
          console.error('Шаг 5: Канва не готова!');
          setTimeout(() => {
            if (isCanvasReady) {
              showCanvas('canvasContainer5');
              if (!isPaused) loop();
            }
          }, 500);
        }
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 50);
      } else if (currentStep === 6) {
        hideCanvas();
        noLoop();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 50);
        setTimeout(debouncedNextStep, 15000);
      } else if (currentStep === 7) {
        hideCanvas();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 50);
      }
    }

    function goBack() {
      if (currentStep <= 0) return;

      const currentStepElement = document.querySelector(`#step${currentStep}`);
      if (currentStepElement) currentStepElement.classList.remove('active');

      currentStep--;
      const previousStepElement = document.querySelector(`#step${currentStep}`);
      if (!previousStepElement) {
        console.error(`Шаг ${currentStep} не найден!`);
        currentStep++;
        return;
      }

      previousStepElement.classList.add('active');
      document.getElementById('backButton').style.display = currentStep > 0 ? 'block' : 'none';
      document.getElementById('continueButton').style.display = currentStep > 0 && currentStep < 7 ? 'block' : 'none';
      updateContinueButtonState();

      if (currentStep === 0 || currentStep === 1) {
        hideCanvas();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 50, currentStep === 1 ? () => setTimeout(debouncedNextStep, 10000) : null);
      } else if (currentStep === 2) {
        hideCanvas();
        document.getElementById('portraitGallery').style.display = 'none';
        noLoop();
        particles = [];
        quantumStates = [];
        frame = 0;
        isPaused = false;
        img = null;
        const step2Buttons = document.getElementById('step2Buttons');
        step2Buttons.innerHTML = `
          <input type="file" id="imageInput" accept="image/*" style="display: none;">
          <button class="button" aria-label="Загрузить фото" onclick="document.getElementById('imageInput').click()">${language === 'ru' ? 'Загрузить фото' : 'Upload Photo'}</button>
          <button class="button" aria-label="Выбрать из архива" onclick="openGallery()">${language === 'ru' ? 'Выбрать готовое' : 'Select from Archive'}</button>
        `;
        typeText('typewriter2', translations.step2[language], 50);
      } else if (currentStep === 3) {
        hideCanvas();
        noLoop();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 50);
      } else if (currentStep === 4) {
        if (isCanvasReady) {
          showCanvas('canvasContainer4');
          if (!isPaused) loop();
        } else {
          console.error('Шаг 4 (назад): Канва не готова!');
          setTimeout(() => {
            if (isCanvasReady) {
              showCanvas('canvasContainer4');
              if (!isPaused) loop();
            }
          }, 500);
        }
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 50);
      } else if (currentStep === 5) {
        if (isCanvasReady) {
          showCanvas('canvasContainer5');
          if (!isPaused) loop();
        } else {
          console.error('Шаг 5 (назад): Канва не готова!');
          setTimeout(() => {
            if (isCanvasReady) {
              showCanvas('canvasContainer5');
              if (!isPaused) loop();
            }
          }, 500);
        }
        document.getElementById('saveButton').style.display = isPaused ? 'block' : 'none';
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 50);
      } else if (currentStep === 6) {
        hideCanvas();
        noLoop();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 50);
        setTimeout(debouncedNextStep, 15000);
      }
    }

    function typeText(elementId, text, speed, callback) {
      let i = 0;
      const element = document.getElementById(elementId);
      if (!element) {
        console.error(`Элемент ${elementId} не найден!`);
        return;
      }
      element.innerHTML = '';
      function type() {
        if (i < text.length) {
          element.innerHTML += text.charAt(i);
          i++;
          setTimeout(type, speed);
        } else if (callback) {
          callback();
        }
      }
      type();
    }

    function triggerFlash() {
      document.getElementById('noiseOverlay').style.opacity = '0.1';
      setTimeout(() => document.getElementById('noiseOverlay').style.opacity = '0', 1000);
      document.getElementById('flashEffect').classList.add('active');
    }

    function restart() {
      currentStep = 0;
      language = 'ru';
      img = null;
      frame = 0;
      isPaused = false;
      particles = [];
      quantumStates = [];

      hideCanvas();
      document.getElementById('portraitGallery').style.display = 'none';
      noLoop();

      document.querySelectorAll('.step').forEach(step => step.classList.remove('active'));

      const step0Element = document.getElementById('step0');
      step0Element.classList.add('active');
      document.getElementById('backButton').style.display = 'none';
      document.getElementById('continueButton').style.display = 'none';
      updateContinueButtonState();
      typeText('typewriter0', translations.step0[language], 50);
    }

    window.onload = () => {
      document.getElementById('step0').classList.add('active');
      typeText('typewriter0', translations.step0[language], 50);
      window.onerror = function(message, source, lineno, colno, error) {
        console.error(`Ошибка: ${message} в ${source}:${lineno}:${colno}`);
        document.body.innerHTML = `<div style="color: white; text-align: center; padding-top: 50px;">
          Произошла ошибка: ${message}. Пожалуйста, обновите страницу или проверьте консоль для деталей.
        </div>`;
      };
    };

    document.getElementById('imageInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        const url = URL.createObjectURL(file);
        loadImageFromUrl(url);
      }
    });

    function openGallery() {
      const gallery = document.getElementById('portraitGallery');
      gallery.innerHTML = '';
      gallery.style.display = 'flex';
      portraitUrls.forEach((url, index) => {
        const div = document.createElement('div');
        div.className = 'portrait';
        div.style.backgroundImage = `url('${url}')`;
        div.setAttribute('aria-label', `Портрет ${index + 1}`);
        div.onclick = () => {
          loadImageFromUrl(url);
          gallery.style.display = 'none';
        };
        gallery.appendChild(div);
      });
    }

    function loadImageFromUrl(url) {
      document.getElementById('loader').style.display = 'block';
      loadImage(url, (loadedImg) => {
        img = loadedImg;
        document.getElementById('portraitGallery').style.display = 'none';
        const typewriter2 = document.getElementById('typewriter2');
        typewriter2.innerHTML = '';
        const step2Buttons = document.getElementById('step2Buttons');
        step2Buttons.innerHTML = '';
        typeText('typewriter2', translations.step2_after[language], 50, () => {
          setTimeout(() => {
            if (img) debouncedNextStep();
          }, 10000);
        });
        document.getElementById('loader').style.display = 'none';
        updateContinueButtonState();
      }, () => {
        document.getElementById('loader').style.display = 'none';
        alert(language === 'ru' ? 'Ошибка загрузки изображения. Попробуйте другое.' : 'Image loading error. Please try another.');
        updateContinueButtonState();
      });
    }

    function openAuthors() {
      document.getElementById('authorsPage').style.display = 'block';
    }

    function closeAuthors() {
      document.getElementById('authorsPage').style.display = 'none';
    }

    function shareObservation() {
      try {
        window.open('https://t.me/quantportrat', '_blank');
        alert(language === 'ru' ? 'Ссылка открыта в новой вкладке.' : 'Link opened in a new tab.');
      } catch (e) {
        console.error('Ошибка при открытии ссылки:', e);
        alert(language === 'ru' ? 'Не удалось открыть ссылку. Проверьте настройки браузера.' : 'Failed to open link. Check browser settings.');
      }
    }

    function goToArchive() {
      try {
        window.open('https://t.me/quantportrat', '_blank');
        alert(language === 'ru' ? 'Ссылка открыта в новой вкладке.' : 'Link opened in a new tab.');
      } catch (e) {
        console.error('Ошибка при открытии ссылки:', e);
        alert(language === 'ru' ? 'Не удалось открыть ссылку. Проверьте настройки браузера.' : 'Failed to open link. Check browser settings.');
      }
    }

    function saveCurrentState() {
      console.log('Сохранение изображения...');
      try {
        if (!canvas) {
          alert(language === 'ru' ? 'Canvas не найден. Убедитесь, что изображение отображается.' : 'Canvas not found. Ensure the image is displayed.');
          return;
        }
        const dataURL = canvas.elt.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = 'quantum-portrait.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        alert(language === 'ru' ? 'Изображение сохранено как quantum-portrait.png' : 'Image saved as quantum-portrait.png');
      } catch (e) {
        console.error('Ошибка сохранения изображения:', e);
        alert(language === 'ru' ? 'Не удалось сохранить изображение. Попробуйте загрузить сайт на хостинг.' : 'Failed to save image. Try hosting the site.');
      }
    }

    function updateContinueButtonText() {
      document.getElementById('continueButton').textContent = language === 'ru' ? 'Продолжить' : 'Continue';
    }

    function updateContinueButtonState() {
      document.getElementById('continueButton').disabled = currentStep === 2 && !img;
    }

    let noiseScale = 0.02;
    let brightColors = [[255, 0, 0], [255, 105, 180], [0, 0, 255], [0, 255, 0], [255, 255, 0]];
    let mouseInfluenceRadius = 100;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let wavePhase = 0;

    function setup() {
      canvas = createCanvas(windowWidth * 0.9, windowHeight * 0.6);
      canvas.parent('canvasContainer4'); // Изначально привязываем к шагу 4
      pixelDensity(1);
      frameRate(30);
      noLoop();
      canvas.elt.style.display = 'none'; // Скрываем по умолчанию

      canvas.elt.addEventListener('click', function() {
        if (currentStep === 5) {
          if (!isPaused) {
            isPaused = true;
            noLoop();
            document.getElementById('saveButton').style.display = 'block';
            console.log('Шаг 5: Пауза, saveButton отображается');
          } else {
            isPaused = false;
            loop();
            document.getElementById('saveButton').style.display = 'none';
            console.log('Шаг 5: Возобновление');
          }
        }
      });

      canvas.elt.addEventListener('touchmove', function(e) {
        e.preventDefault();
        const touch = e.touches[0];
        mouseX = touch.clientX - canvas.elt.offsetLeft;
        mouseY = touch.clientY - canvas.elt.offsetTop;
      });

      window.addEventListener('resize', () => {
        resizeCanvas(windowWidth * 0.9, windowHeight * 0.6);
      });

      lastMouseX = mouseX;
      lastMouseY = mouseY;
      isCanvasReady = true;
      console.log('setup: Канва создана и готова');
    }

    function draw() {
      if (!img || !img.width || quantumStates.length === 0) {
        if (img && img.width) {
          let centerX = width / 2;
          let centerY = height / 2;
          let scaleFactor = min(width, height) / 512;
          let gridSize = Math.max(4 / scaleFactor, 1);
          for (let y = 0; y < 256; y += gridSize) {
            for (let x = 0; x < 256; x += gridSize) {
              let pixelX = constrain(x, 0, 255);
              let pixelY = constrain(y, 0, 255);
              let col = img.get(pixelX, pixelY);
              let brightnessVal = brightness(col);
              if (brightnessVal > 20) {
                let size = random(4, 8) * scaleFactor;
                let shapeType = floor(random(4));
                let distFromCenter = dist(x, y, 128, 128);
                let densityFactor = map(distFromCenter, 0, 128, 1, 0.3);
                if (random() < densityFactor && particles.length < 2000) {
                  particles.push({
                    x: centerX - 128 * scaleFactor + x * scaleFactor,
                    y: centerY - 128 * scaleFactor + y * scaleFactor,
                    baseX: centerX - 128 * scaleFactor + x * scaleFactor,
                    baseY: centerY - 128 * scaleFactor + y * scaleFactor,
                    offsetX: 0,
                    offsetY: 0,
                    size: size,
                    phase: random(TWO_PI),
                    entangledWith: null,
                    gridX: x,
                    gridY: y,
                    shapeType: shapeType,
                    wavePhase: 0,
                    waveInfluence: 0,
                    baseColor: [red(col), green(col), blue(col)],
                    tunneled: false,
                    tunnelTargetX: 0,
                    tunnelTargetY: 0,
                    tunnelReturnSpeed: 0.02
                  });
                }
              }
            }
          }

          img.loadPixels();
          for (let i = 0; i < particles.length; i++) {
            let particle = particles[i];
            let pixelX = constrain(Math.floor((particle.baseX - (centerX - 128 * scaleFactor)) / scaleFactor), 0, img.width - 1);
            let pixelY = constrain(Math.floor((particle.baseY - (centerY - 128 * scaleFactor)) / scaleFactor), 0, img.height - 1);
            let col = img.get(pixelX, pixelY);
            let entangledIndex = null;
            if (random() < 0.3) {
              let potentialPartners = particles.filter((p, idx) => idx !== i && !p.entangledWith);
              if (potentialPartners.length > 0) {
                let partner = random(potentialPartners);
                entangledIndex = particles.indexOf(partner);
                partner.entangledWith = i;
              }
            }
            quantumStates[i] = {
              r: red(col),
              g: green(col),
              b: blue(col),
              a: alpha(col),
              baseR: red(col),
              baseG: green(col),
              baseB: blue(col),
              superpositionStates: [
                { r: red(col) + random(-30, 30), g: green(col) + random(-30, 30), b: blue(col) + random(-30, 30) },
                { r: red(col) + random(-30, 30), g: green(col) + random(-30, 30), b: blue(col) + random(-30, 30) }
              ],
              collapsed: false,
              entangledWith: entangledIndex,
              phase: random(TWO_PI),
              amplitude: random(30, 60) * scaleFactor,
              isLips: (pixelY > img.height * 0.47 && pixelY < img.height * 0.55 && pixelX > img.width * 0.35 && pixelX < img.width * 0.65),
              isEyes: ((pixelY > img.height * 0.31 && pixelY < img.height * 0.39) && ((pixelX > img.width * 0.31 && pixelX < img.width * 0.43) || (pixelX > img.width * 0.57 && pixelX < img.width * 0.69))),
              isHair: (pixelY < img.height * 0.31),
              brightColor: null
            };
          }
        }
        return;
      }

      frame += 1;
      let transitionPhase = map(frame, 0, 120, 0, 1);

      background(0);

      let ghostAlpha = 150 * (1 - transitionPhase * 0.6);
      tint(255, ghostAlpha);
      image(img, width / 2 - 128 * (min(width, height) / 512), height / 2 - 128 * (min(width, height) / 512), 256 * (min(width, height) / 512), 256 * (min(width, height) / 512));
      noTint();

      let mouseSpeed = dist(mouseX, mouseY, lastMouseX, lastMouseY);
      if (mouseSpeed > 0 && !isPaused) wavePhase += 0.1;
      lastMouseX = mouseX;
      lastMouseY = mouseY;

      for (let i = 0; i < particles.length; i++) {
        let particle = particles[i];
        let state = quantumStates[i];
        if (state.entangledWith !== null) {
          let entangledParticle = particles[state.entangledWith];
          let alpha = 100 * (0.5 + 0.5 * sin(frame * 0.03));
          stroke(255, alpha);
          strokeWeight(0.5);
          noFill();
          beginShape();
          for (let t = 0; t <= 1; t += 0.05) {
            let x = lerp(particle.x + particle.offsetX, entangledParticle.x + entangledParticle.offsetX, t);
            let y = lerp(particle.y + particle.offsetY, entangledParticle.y + entangledParticle.offsetY, t);
            let offset = noise(x * 0.01, y * 0.01, frame * 0.02) * 10;
            vertex(x + offset, y + offset);
          }
          endShape();
        }
      }

      for (let i = 0; i < particles.length; i++) {
        let particle = particles[i];
        let state = quantumStates[i];
        let speedFactor = 1.0;
        if (state.isEyes) speedFactor = 1.5;
        if (state.isLips) speedFactor = 1.2;
        if (state.isHair) speedFactor = 0.8;

        let d = dist(mouseX, mouseY, particle.x + particle.offsetX, particle.y + particle.offsetY);
        if (d < mouseInfluenceRadius && !isPaused) {
          particle.waveInfluence = map(d, 0, mouseInfluenceRadius, 1, 0);
          particle.wavePhase = wavePhase - d * 0.05;
        } else {
          particle.waveInfluence = 0;
        }

        let noiseVal = noise(particle.baseX * noiseScale, particle.baseY * noiseScale, frame * 0.01);
        let distFromCenter = dist(particle.baseX, particle.baseY, width / 2, height / 2);
        let maxAmplitude = map(distFromCenter, 0, 128 * (min(width, height) / 512), 20, 60);
        let positionUncertainty = map(d, 0, mouseInfluenceRadius, 0.1, 1);
        let baseOffsetX = sin(state.phase) * state.amplitude * noiseVal * speedFactor * (maxAmplitude / 150) * positionUncertainty;
        let baseOffsetY = cos(state.phase) * state.amplitude * noiseVal * speedFactor * (maxAmplitude / 150) * positionUncertainty;

        let waveOffsetX = 0;
        let waveOffsetY = 0;
        if (particle.waveInfluence > 0 && !isPaused) {
          waveOffsetX = sin(particle.wavePhase) * 30 * particle.waveInfluence;
          waveOffsetY = cos(particle.wavePhase) * 30 * particle.waveInfluence;
        }

        let centerDist = dist(particle.x, particle.y, width / 2, height / 2);
        if (!particle.tunneled && centerDist > 128 * (min(width, height) / 512) && random() < 0.01 && !isPaused) {
          particle.tunneled = true;
          particle.tunnelTargetX = random(width);
          particle.tunnelTargetY = random(height);
        }
        if (particle.tunneled) {
          particle.offsetX = lerp(particle.offsetX, particle.tunnelTargetX - particle.x, particle.tunnelReturnSpeed);
          particle.offsetY = lerp(particle.offsetY, particle.tunnelTargetY - particle.y, particle.tunnelReturnSpeed);
          if (dist(particle.x + particle.offsetX, particle.y + particle.offsetY, particle.tunnelTargetX, particle.tunnelTargetY) < 10) {
            particle.tunneled = false;
          }
        }

        particle.offsetX = baseOffsetX + waveOffsetX;
        particle.offsetY = baseOffsetY + waveOffsetY;

        let dx = particle.baseX - (particle.x + particle.offsetX);
        particle.x += dx * 0.03;
        particle.offsetX += dx * 0.03;
        let dy = particle.baseY - (particle.y + particle.offsetY);
        particle.y += dy * 0.03;
        particle.offsetY += dy * 0.03;

        state.phase += 0.02 * speedFactor;

        let colorUncertainty = map(d, 0, mouseInfluenceRadius, 0, 0.05);
        if (random() < colorUncertainty && !isPaused) {
          if (random() < 0.5 && !state.collapsed) {
            let newState = random(state.superpositionStates);
            state.r = newState.r;
            state.g = newState.g;
            state.b = newState.b;
          } else if (random() < 0.01 && !state.brightColor) {
            state.brightColor = random(brightColors);
          }
        } else {
          state.r = state.baseR;
          state.g = state.baseG;
          state.b = state.baseB;
          state.brightColor = null;
        }

        if (d < 50 && !state.collapsed && !isPaused) {
          state.collapsed = true;
          let chosenState = random(state.superpositionStates);
          state.r = chosenState.r;
          state.g = chosenState.g;
          state.b = chosenState.b;

          if (state.entangledWith !== null) {
            let entangledState = quantumStates[state.entangledWith];
            if (!entangledState.collapsed) {
              entangledState.collapsed = true;
              entangledState.r = chosenState.r;
              entangledState.g = chosenState.g;
              entangledState.b = chosenState.b;
            }
          }
        }

        if (!state.collapsed) {
          let t = 0.5 + 0.5 * sin(frame * 0.05 + state.phase);
          state.r = lerp(state.superpositionStates[0].r, state.superpositionStates[1].r, t) * (1 - colorUncertainty) + state.baseR * colorUncertainty;
          state.g = lerp(state.superpositionStates[0].g, state.superpositionStates[1].g, t) * (1 - colorUncertainty) + state.baseG * colorUncertainty;
          state.b = lerp(state.superpositionStates[0].b, state.superpositionStates[1].b, t) * (1 - colorUncertainty) + state.baseB * colorUncertainty;
        }

        push();
        translate(particle.x + particle.offsetX, particle.y + particle.offsetY);
        noStroke();
        let alpha = state.a * (0.5 + 0.5 * sin(frame * 0.05 + state.phase));
        if (state.brightColor) {
          fill(state.brightColor[0], state.brightColor[1], state.brightColor[2], alpha * 0.8);
        } else {
          fill(state.r, state.g, state.b, alpha * 0.8);
        }

        let uncertainty = map(d, 0, mouseInfluenceRadius, 0, 1);
        if (random() < uncertainty * 0.02 && !isPaused) particle.shapeType = floor(random(4));

        switch (particle.shapeType) {
          case 0:
            beginShape();
            for (let angle = 0; angle < TWO_PI; angle += 0.1) {
              let r = particle.size * (1 + 0.3 * noise(particle.x * 0.01, particle.y * 0.01, frame * 0.02));
              let x = r * cos(angle);
              let y = r * sin(angle);
              vertex(x, y);
            }
            endShape(CLOSE);
            break;
          case 1:
            rect(-particle.size / 2, -particle.size / 2, particle.size, particle.size);
            break;
          case 2:
            triangle(-particle.size / 2, particle.size / 2, particle.size / 2, particle.size / 2, 0, -particle.size / 2);
            break;
          case 3:
            let shear = particle.size * 0.3;
            quad(-particle.size / 2, -particle.size / 2, particle.size / 2 - shear, -particle.size / 2, particle.size / 2, particle.size / 2, -particle.size / 2 + shear, particle.size / 2);
            break;
        }
        pop();
      }
    }
  </script>
</body>
</html>