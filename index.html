<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quantum Portraits</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      color: #fff;
      font-family: 'Courier New', Courier, monospace;
      height: 100vh;
      overflow-y: auto;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .container {
      position: relative;
      width: 90%;
      max-width: 800px;
      min-height: 100vh;
      padding: 40px 20px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    .step {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      flex-grow: 1;
    }
    .step.active {
      display: flex;
    }
    .text-container {
      width: 100%;
      padding: 20px;
      text-align: center;
      margin-bottom: 20px;
      flex-shrink: 0;
    }
    .text-container p {
      margin: 15px 0;
      line-height: 1.6;
    }
    .typewriter {
      font-size: 1.2rem;
      line-height: 1.5;
      white-space: pre-wrap;
      color: #e7c2f4;
      text-shadow: 0 0 10px #d800ff;
    }
    .typewriter.status {
      font-size: 1.4rem;
      font-weight: bold;
      color: #e7c2f4;
      text-shadow: 0 0 15px #d800ff;
    }
    .typewriter.outcome {
      background: #fff;
      color: #000;
      padding: 10px;
      border: 2px solid #e7c2f4;
      text-shadow: none;
      display: inline-block;
    }
    .button-container {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      padding: 10px;
      flex-shrink: 0;
    }
    .button {
      padding: 10px 20px;
      background: none;
      border: 2px solid #e7c2f4;
      color: #e7c2f4;
      font-family: 'Courier New', Courier, monospace;
      cursor: pointer;
      transition: background 0.3s, text-shadow 0.3s;
      font-size: 1rem;
    }
    .button:hover, .button:focus {
      background: #333;
      text-shadow: 0 0 10px #d800ff;
    }
    .button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .save-button {
      padding: 10px 20px;
      background: none;
      border: 2px solid #e7c2f4;
      color: #e7c2f4;
      font-family: 'Courier New', Courier, monospace;
      cursor: pointer;
      transition: background 0.3s;
      margin: 10px auto;
    }
    .save-button:hover, .save-button:focus {
      background: #333;
      text-shadow: 0 0 10px #d800ff;
    }
    .back-button {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 10px 20px;
      background: none;
      border: 2px solid #e7c2f4;
      color: #e7c2f4;
      font-family: 'Courier New', Courier, monospace;
      cursor: pointer;
      transition: background 0.3s;
      z-index: 10;
    }
    .back-button:hover, .back-button:focus {
      background: #333;
      text-shadow: 0 0 10px #d800ff;
    }
    canvas {
      display: none;
      border: 2px solid #e7c2f4;
      width: 100%;
      max-width: 512px;
      height: auto;
      max-height: calc(100vh - 250px);
      object-fit: contain;
      margin: 20px 0;
      z-index: 1;
      cursor: pointer;
    }
    .user-image {
      display: none;
      max-width: 200px;
      max-height: 200px;
      object-fit: contain;
      margin: 20px;
      border: 2px solid #e7c2f4;
    }
    .canvas-container {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      gap: 20px;
    }
    #noiseOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0;
      background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABYSURBVGhD7c0hAQAgDAAx3L9tN4ZgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBg thingyGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBg4D8P4wF1N8lKtwAAAABJRU5ErkJggg==');
      animation: noise 0.1s infinite;
    }
    @keyframes noise {
      0% { background-position: 0 0; }
      100% { background-position: 50px 50px; }
    }
    .flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #fff;
      opacity: 0;
      pointer-events: none;
    }
    .flash.active {
      animation: flash 0.3s;
    }
    @keyframes flash {
      0% { opacity: 0; }
      50% { opacity: 0.5; }
      100% { opacity: 0; }
    }
    #portraitGallery {
      display: none;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin: 20px 0;
      width: 100%;
    }
    .portrait {
      width: 100px;
      height: 100px;
      background: #333;
      cursor: pointer;
      border: 2px solid #e7c2f4;
    }
    #authorsPage {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 20;
      padding: 40px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #loader {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #e7c2f4;
      font-size: 1.5rem;
      display: none;
    }
    .other-cursor {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #e7c2f4;
      border-radius: 50%;
      opacity: 0.5;
      pointer-events: none;
      z-index: 5;
    }

    @media (max-width: 768px) {
      .container {
        padding: 20px 10px;
      }
      .text-container {
        font-size: 1rem;
      }
      .typewriter.status {
        font-size: 1.2rem;
      }
      .button-container {
        flex-direction: column;
        align-items: center;
      }
      .button, .save-button {
        width: 80%;
        margin: 10px 0;
      }
      canvas {
        max-height: calc(100vh - 300px);
      }
      .user-image {
        max-width: 150px;
        max-height: 150px;
      }
      .canvas-container {
        flex-direction: column;
      }
    }
    @media (max-width: 480px) {
      .text-container {
        font-size: 0.9rem;
      }
      .typewriter.status {
        font-size: 1.1rem;
      }
      .portrait {
        width: 80px;
        height: 80px;
      }
      canvas {
        max-height: calc(100vh - 350px);
      }
      .user-image {
        max-width: 120px;
        max-height: 120px;
      }
    }
  </style>
</head>
<body>
  <div id="noiseOverlay"></div>
  <div class="flash" id="flashEffect"></div>
  <div id="loader">Загрузка...</div>
  <div class="container">
    <button class="back-button" id="backButton" style="display: none;" aria-label="Вернуться на предыдущий шаг" onclick="debouncedGoBack()">Назад / Back</button>

    <!-- Шаг 0: Выбор языка -->
    <div class="step active" id="step0">
      <div class="text-container">
        <div class="typewriter" id="typewriter0"></div>
      </div>
      <div class="button-container" id="step0Buttons">
        <button class="button" aria-label="Выбрать русский язык" onclick="selectLanguage('ru')">RU</button>
        <button class="button" aria-label="Выбрать английский язык" onclick="selectLanguage('en')">ENG</button>
      </div>
    </div>

    <!-- Шаг 1: Приветствие -->
    <div class="step" id="step1">
      <div class="text-container">
        <div class="typewriter status" id="typewriter1"></div>
      </div>
      <div class="button-container">
        <button class="button" aria-label="Начать" onclick="debouncedNextStep()">${language === 'ru' ? 'Начать / Start' : 'Start'}</button>
      </div>
    </div>

    <!-- Шаг 2: Загрузка портрета -->
    <div class="step" id="step2">
      <div class="text-container">
        <div class="typewriter status" id="typewriter2"></div>
      </div>
      <div class="button-container" id="step2Buttons">
        <input type="file" id="imageInput" accept="image/*" style="display: none;">
        <button class="button" aria-label="Загрузить фото" onclick="document.getElementById('imageInput').click()">Загрузить фото / Upload Photo</button>
        <button class="button" aria-label="Выбрать из архива" onclick="openGallery()">Выбрать готовое / Select from Archive</button>
      </div>
    </div>

    <!-- Шаг 3: Промежуточный -->
    <div class="step" id="step3">
      <div class="text-container">
        <div class="typewriter" id="typewriter3"></div>
      </div>
      <div class="button-container">
        <button class="button" aria-label="Инициализировать" onclick="debouncedNextStep()">Инициализировать / Initialize</button>
      </div>
    </div>

    <!-- Шаг 4: Инициализация -->
    <div class="step" id="step4">
      <div class="text-container">
        <div class="typewriter status" id="typewriter4"></div>
      </div>
      <div class="button-container">
        <button class="button" aria-label="Запустить коллапс" onclick="debouncedNextStep()">Запустить коллапс / Trigger Collapse</button>
      </div>
    </div>

    <!-- Шаг 5: Наблюдение -->
    <div class="step" id="step5">
      <div class="text-container">
        <div class="typewriter status" id="typewriter5"></div>
      </div>
      <div class="canvas-container" id="canvasContainer5">
        <img id="userImage" class="user-image" style="display: none;">
      </div>
      <button class="continue-button" id="continueButton" style="display: none;" aria-label="Продолжить" onclick="debouncedNextStep()">Продолжить / Continue</button>
    </div>

    <!-- Шаг 6: Фиксация -->
    <div class="step" id="step6">
      <div class="text-container">
        <div class="typewriter status" id="typewriter6"></div>
      </div>
      <div class="canvas-container" id="canvasContainer6"></div>
      <button class="save-button" id="saveButton" style="display: none;" aria-label="Зафиксировать наблюдение" onclick="fixObservation()">Зафиксировать наблюдение / Fix Observation</button>
    </div>

    <!-- Шаг 7: Реакция системы -->
    <div class="step" id="step7">
      <div class="text-container">
        <div class="typewriter status" id="typewriter7"></div>
      </div>
      <div class="button-container">
        <button class="button" aria-label="Поделиться наблюдением" onclick="shareObservation()">Поделиться наблюдением / Share Observation</button>
        <button class="button continue-button" aria-label="Продолжить" onclick="debouncedNextStep()">Продолжить / Continue</button>
      </div>
    </div>

    <!-- Шаг 8: Завершение -->
    <div class="step" id="step8">
      <div class="text-container">
        <div class="typewriter status" id="typewriter8"></div>
      </div>
      <div class="button-container">
        <button class="button" aria-label="Вернуться к неопределенности" onclick="returnToUncertainty()">Вернуться к неопределенности / Return to Uncertainty</button>
        <button class="button" aria-label="Перейти в архив" onclick="goToArchive()">Сеть реакций / Network of Reactions</button>
        <button class="button" aria-label="О разработчиках" onclick="openAuthors()">Об авторах / About Us</button>
      </div>
    </div>

    <div id="portraitGallery"></div>
    <div id="authorsPage">
      <button class="button" aria-label="Закрыть страницу авторов" onclick="closeAuthors()">Закрыть / Close</button>
      <div class="text-container">
        <div class="typewriter">Слава Саша</div>
      </div>
    </div>
  </div>

  <script>
    let currentStep = 0;
    let language = 'ru';
    let img;
    let userImageUrl;
    let frame = 0;
    let isPaused = false;
    let particles = [];
    let quantumStates = [];
    let canvas;
    let isCanvasReady = false;
    let formationPhase = 0;

    const portraitUrls = [
      'images/portrait1.png',
      'images/portrait2.png',
      'images/portrait3.png'
    ];

    const translations = {
      step0: { ru: 'Пожалуйста, выберите язык\nPlease select a language', en: 'Please select a language' },
      step1: { 
        ru: 'СТАТУС: НАБЛЮДАТЕЛЬ ПОДКЛЮЧЕН\n\nЧему Шредингер может научить нас в области\nцифровой идентификации?\n\nДобро пожаловать в экспериментальную зону.\n\nЗдесь наблюдение = вмешательство.', 
        en: 'STATUS: OBSERVER CONNECTED\n\nWhat can Schrödinger teach us about\ndigital identification?\n\nWelcome to the experimental zone.\n\nHere, observation = interference.' 
      },
      step2: { 
        ru: 'ШАГ 1: НАЧАЛО\n\nСканируйте лицо суперпозиции.\n\nЗагрузите изображение, включите камеру или выберите из архива.', 
        en: 'STEP 1: BEGINNING\n\nScan the face of superposition.\n\nUpload an image, enable the camera, or select from the archive.' 
      },
      step3: { 
        ru: '> Изображение принято.\n> Запускается волновая функция.\n> Система готова к инициализации.', 
        en: '> Image accepted.\n> Wave function launching.\n> System ready for initialization.' 
      },
      step4: { 
        ru: 'ШАГ 2: ИНИЦИАЛИЗАЦИЯ\n\n> Изображение преобразовано в пиксельную сетку.\n> Каждому пикселю назначены параметры (x, y, brightness, color).\n> На их основе построена волновая функция: ψ(x, y, t).\n\nУравнение эволюции:\niℏ ∂ψ/∂t = Ĥψ, где Ĥ = -½∇² + V(x, y)\n\n> Потенциал V(x, y) формируется из визуальных характеристик изображения.\n> Система переходит в режим временной симуляции.\n> Портрет существует как совокупность возможных состояний.', 
        en: 'STEP 2: INITIALIZATION\n\n> Image converted into a pixel grid.\n> Each pixel assigned parameters (x, y, brightness, color).\n> Based on them, a wave function is built: ψ(x, y, t).\n\nEvolution equation:\niℏ ∂ψ/∂t = Ĥψ, where Ĥ = -½∇² + V(x, y)\n\n> Potential V(x, y) is formed from the visual characteristics of the image.\n> System enters temporal simulation mode.\n> The portrait exists as a set of possible states.' 
      },
      step5: { 
        ru: 'ШАГ 3: НАЧНИТЕ НАБЛЮДЕНИЕ\n\nДвигайте курсором по изображению.\nКаждый ваш жест запускает коллапс.\nСистема реагирует.\nНаблюдаемый образ формируется здесь и сейчас.', 
        en: 'STEP 3: BEGIN OBSERVATION\n\nMove the cursor over the image.\nEach gesture triggers a collapse.\nThe system reacts.\nThe observed image is formed here and now.' 
      },
      step6: { 
        ru: 'ШАГ 4: ФИКСАЦИЯ\n\nПортрет — это процесс.\nНо ты можешь зафиксировать один миг.\nЭто будет один из возможных тебя.', 
        en: 'STEP 4: FIXATION\n\nA portrait is a process.\nBut you can fix a single moment.\nThis will be one of your possible selves.' 
      },
      step7: { 
        ru: 'ШАГ 5: РЕАКЦИЯ СИСТЕМЫ\n\nЭто не портрет.\nЭто — реакция системы на тебя.\n\nТы повлиял на исход', 
        en: 'STEP 5: SYSTEM REACTION\n\nThis is not a portrait.\nThis is the system\'s reaction to you.\n\nYou influenced the outcome' 
      },
      step8: { 
        ru: 'ТЫ - НЕ ЕДИНСТВЕННЫЙ НАБЛЮДАТЕЛЬ\n\nКаждое наблюдение — это акт, формирующий образ.\nЗдесь ты — одновременно субъект и объект.', 
        en: 'YOU ARE NOT THE ONLY OBSERVER\n\nEach observation is an act that shapes the image.\nHere, you are both subject and object.' 
      }
    };

    // Debouncing
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    const debouncedNextStep = debounce(nextStep, 300);
    const debouncedGoBack = debounce(goBack, 300);

    function selectLanguage(lang) {
      language = lang;
      debouncedNextStep();
    }

    function showCanvas(containerId) {
      if (!canvas) {
        console.error(`Канва не создана для ${containerId}!`);
        return;
      }
      const canvasElement = canvas.elt;
      const currentParent = canvasElement.parentElement;
      if (currentParent) {
        currentParent.removeChild(canvasElement);
      }
      const container = document.getElementById(containerId);
      if (container) {
        container.appendChild(canvasElement);
        canvasElement.style.display = 'block';
        console.log(`Канва перемещена в ${containerId} и отображается`);
      } else {
        console.error(`Контейнер ${containerId} не найден!`);
      }
    }

    function hideCanvas() {
      if (canvas) {
        canvas.elt.style.display = 'none';
        console.log('Канва скрыта');
      }
    }

    function showUserImage() {
      const userImage = document.getElementById('userImage');
      if (userImageUrl) {
        userImage.src = userImageUrl;
        userImage.style.display = 'block';
      }
    }

    function hideUserImage() {
      const userImage = document.getElementById('userImage');
      userImage.style.display = 'none';
    }

    function nextStep() {
      if (currentStep >= 8) return;

      if (currentStep === 2 && !img) {
        alert(language === 'ru' ? 'Пожалуйста, загрузите фото или выберите из архива.' : 'Please upload a photo or select from the archive.');
        return;
      }

      const currentStepElement = document.querySelector(`#step${currentStep}`);
      if (currentStepElement) currentStepElement.classList.remove('active');

      currentStep++;
      const nextStepElement = document.querySelector(`#step${currentStep}`);
      if (!nextStepElement) {
        console.error(`Шаг ${currentStep} не найден!`);
        currentStep--;
        return;
      }

      nextStepElement.classList.add('active');
      document.getElementById('backButton').style.display = currentStep > 0 ? 'block' : 'none';
      document.getElementById('continueButton').style.display = (currentStep === 5 || currentStep === 7) ? 'block' : 'none';

      if (currentStep === 1) {
        triggerFlash();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35);
      } else if (currentStep === 2) {
        hideCanvas();
        hideUserImage();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35);
      } else if (currentStep === 3) {
        if (!img) {
          debouncedGoBack();
          return;
        }
        triggerFlash();
        hideCanvas();
        hideUserImage();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 700, 0, 35);
      } else if (currentStep === 4) {
        hideCanvas();
        hideUserImage();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35);
      } else if (currentStep === 5) {
        if (isCanvasReady) {
          showCanvas('canvasContainer5');
          showUserImage();
          formationPhase = 0;
          loop();
        } else {
          console.error('Шаг 5: Канва не готова!');
          setTimeout(() => {
            if (isCanvasReady) {
              showCanvas('canvasContainer5');
              showUserImage();
              formationPhase = 0;
              loop();
            }
          }, 500);
        }
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35);
      } else if (currentStep === 6) {
        if (isCanvasReady) {
          showCanvas('canvasContainer6');
          showUserImage();
          if (!isPaused) loop();
        } else {
          console.error('Шаг 6: Канва не готова!');
          setTimeout(() => {
            if (isCanvasReady) {
              showCanvas('canvasContainer6');
              showUserImage();
              if (!isPaused) loop();
            }
          }, 500);
        }
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35);
      } else if (currentStep === 7) {
        hideCanvas();
        hideUserImage();
        noLoop();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35, () => {
          const typewriter7 = document.getElementById('typewriter7');
          const outcomeText = document.createElement('p');
          outcomeText.className = 'typewriter outcome';
          outcomeText.textContent = language === 'ru' ? 'Ты повлиял на исход' : 'You influenced the outcome';
          typewriter7.appendChild(outcomeText);
        });
      } else if (currentStep === 8) {
        hideCanvas();
        hideUserImage();
        noLoop();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35);
      }
    }

    function goBack() {
      if (currentStep <= 0) return;

      const currentStepElement = document.querySelector(`#step${currentStep}`);
      if (currentStepElement) currentStepElement.classList.remove('active');

      currentStep--;
      const previousStepElement = document.querySelector(`#step${currentStep}`);
      if (!previousStepElement) {
        console.error(`Шаг ${currentStep} не найден!`);
        currentStep++;
        return;
      }

      previousStepElement.classList.add('active');
      document.getElementById('backButton').style.display = currentStep > 0 ? 'block' : 'none';
      document.getElementById('continueButton').style.display = (currentStep === 5 || currentStep === 7) ? 'block' : 'none';

      if (currentStep === 0) {
        hideCanvas();
        hideUserImage();
        const step0Buttons = document.getElementById('step0Buttons');
        step0Buttons.innerHTML = `
          <button class="button" aria-label="Выбрать русский язык" onclick="selectLanguage('ru')">RU</button>
          <button class="button" aria-label="Выбрать английский язык" onclick="selectLanguage('en')">ENG</button>
        `;
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35);
      } else if (currentStep === 1) {
        hideCanvas();
        hideUserImage();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35);
      } else if (currentStep === 2) {
        hideCanvas();
        hideUserImage();
        document.getElementById('portraitGallery').style.display = 'none';
        noLoop();
        particles = [];
        quantumStates = [];
        frame = 0;
        formationPhase = 0;
        isPaused = false;
        img = null;
        userImageUrl = null;
        const step2Buttons = document.getElementById('step2Buttons');
        step2Buttons.innerHTML = `
          <input type="file" id="imageInput" accept="image/*" style="display: none;">
          <button class="button" aria-label="Загрузить фото" onclick="document.getElementById('imageInput').click()">${language === 'ru' ? 'Загрузить фото / Upload Photo' : 'Upload Photo'}</button>
          <button class="button" aria-label="Выбрать из архива" onclick="openGallery()">${language === 'ru' ? 'Выбрать готовое / Select from Archive' : 'Select from Archive'}</button>
        `;
        typeText('typewriter2', translations.step2[language], 600, 70, 35);
      } else if (currentStep === 3) {
        hideCanvas();
        hideUserImage();
        noLoop();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 700, 0, 35);
      } else if (currentStep === 4) {
        hideCanvas();
        hideUserImage();
        noLoop();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35);
      } else if (currentStep === 5) {
        if (isCanvasReady) {
          showCanvas('canvasContainer5');
          showUserImage();
          formationPhase = 0;
          if (!isPaused) loop();
        } else {
          console.error('Шаг 5 (назад): Канва не готова!');
          setTimeout(() => {
            if (isCanvasReady) {
              showCanvas('canvasContainer5');
              showUserImage();
              formationPhase = 0;
              if (!isPaused) loop();
            }
          }, 500);
        }
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35);
      } else if (currentStep === 6) {
        if (isCanvasReady) {
          showCanvas('canvasContainer6');
          showUserImage();
          if (!isPaused) loop();
        } else {
          console.error('Шаг 6 (назад): Канва не готова!');
          setTimeout(() => {
            if (isCanvasReady) {
              showCanvas('canvasContainer6');
              showUserImage();
              if (!isPaused) loop();
            }
          }, 500);
        }
        document.getElementById('saveButton').style.display = isPaused ? 'block' : 'none';
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35);
      } else if (currentStep === 7) {
        hideCanvas();
        hideUserImage();
        noLoop();
        typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35, () => {
          const typewriter7 = document.getElementById('typewriter7');
          const outcomeText = document.createElement('p');
          outcomeText.className = 'typewriter outcome';
          outcomeText.textContent = language === 'ru' ? 'Ты повлиял на исход' : 'You influenced the outcome';
          typewriter7.appendChild(outcomeText);
        });
      }
    }

    function typeText(elementId, text, initialDelay, statusSpeed, textSpeed, callback) {
      let i = 0;
      const element = document.getElementById(elementId);
      if (!element) {
        console.error(`Элемент ${elementId} не найден!`);
        return;
      }
      element.innerHTML = '';
      const lines = text.split('\n');
      let currentLine = 0;

      function typeLine() {
        if (currentLine >= lines.length) {
          if (callback) callback();
          return;
        }
        const line = lines[currentLine];
        const isStatusLine = line.match(/^(СТАТУС|STATUS|ШАГ|STEP|TЫ|YOU)/i);
        const speed = isStatusLine ? statusSpeed : textSpeed;
        const delay = isStatusLine && currentLine === 0 ? initialDelay : 0;
        let j = 0;
        const lineElement = document.createElement('p');
        lineElement.className = isStatusLine ? 'typewriter status' : 'typewriter';
        element.appendChild(lineElement);

        function typeChar() {
          if (j < line.length) {
            lineElement.innerHTML += line.charAt(j);
            j++;
            setTimeout(typeChar, speed);
          } else {
            currentLine++;
            setTimeout(typeLine, 100);
          }
        }
        setTimeout(typeChar, delay);
      }
      setTimeout(typeLine, initialDelay);
    }

    function triggerFlash() {
      document.getElementById('noiseOverlay').style.opacity = '0.1';
      setTimeout(() => document.getElementById('noiseOverlay').style.opacity = '0', 1000);
      document.getElementById('flashEffect').classList.add('active');
      setTimeout(() => document.getElementById('flashEffect').classList.remove('active'), 300);
    }

    function restart() {
      currentStep = 0;
      language = 'ru';
      img = null;
      userImageUrl = null;
      frame = 0;
      formationPhase = 0;
      isPaused = false;
      particles = [];
      quantumStates = [];
      isCanvasReady = false;

      if (canvas) {
        canvas.remove();
        canvas = null;
      }
      noLoop();

      document.getElementById('portraitGallery').style.display = 'none';
      document.getElementById('authorsPage').style.display = 'none';
      document.querySelectorAll('.step').forEach(step => step.classList.remove('active'));

      const step0Element = document.getElementById('step0');
      step0Element.classList.add('active');
      const step0Buttons = document.getElementById('step0Buttons');
      step0Buttons.innerHTML = `
        <button class="button" aria-label="Выбрать русский язык" onclick="selectLanguage('ru')">RU</button>
        <button class="button" aria-label="Выбрать английский язык" onclick="selectLanguage('en')">ENG</button>
      `;
      document.getElementById('backButton').style.display = 'none';
      document.getElementById('continueButton').style.display = 'none';
      typeText('typewriter0', translations.step0[language], 600, 70, 35);
      setup();
    }

    window.onload = () => {
      document.getElementById('step0').classList.add('active');
      typeText('typewriter0', translations.step0[language], 600, 70, 35);
      window.onerror = function(message, source, lineno, colno, error) {
        console.error(`Ошибка: ${message} в ${source}:${lineno}:${colno}`);
        document.body.innerHTML = `<div style="color: #e7c2f4; text-align: center; padding-top: 50px;">
          Произошла ошибка: ${message}. Пожалуйста, обновите страницу или проверьте консоль для деталей.
        </div>`;
      };
    };

    document.getElementById('imageInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        const url = URL.createObjectURL(file);
        loadImageFromUrl(url);
      }
    });

    function openGallery() {
      const gallery = document.getElementById('portraitGallery');
      gallery.innerHTML = '';
      gallery.style.display = 'flex';
      portraitUrls.forEach((url, index) => {
        const div = document.createElement('div');
        div.className = 'portrait';
        div.style.backgroundImage = `url('${url}')`;
        div.setAttribute('aria-label', `Портрет ${index + 1}`);
        div.onclick = () => {
          loadImageFromUrl(url);
          gallery.style.display = 'none';
        };
        gallery.appendChild(div);
      });
    }

    function loadImageFromUrl(url) {
      document.getElementById('loader').style.display = 'block';
      loadImage(url, (loadedImg) => {
        img = loadedImg;
        userImageUrl = url;
        document.getElementById('portraitGallery').style.display = 'none';
        const typewriter2 = document.getElementById('typewriter2');
        typewriter2.innerHTML = '';
        const step2Buttons = document.getElementById('step2Buttons');
        step2Buttons.innerHTML = '';
        typeText('typewriter2', translations.step3[language], 700, 0, 35, () => {
          const buttonContainer = document.getElementById('step2Buttons');
          buttonContainer.innerHTML = `
            <button class="button" aria-label="Инициализировать" onclick="debouncedNextStep()">Инициализировать / Initialize</button>
          `;
        });
        document.getElementById('loader').style.display = 'none';
      }, () => {
        document.getElementById('loader').style.display = 'none';
        alert(language === 'ru' ? 'Ошибка загрузки изображения. Попробуйте другое.' : 'Image loading error. Please try another.');
      });
    }

    function openAuthors() {
      document.getElementById('authorsPage').style.display = 'flex';
    }

    function closeAuthors() {
      document.getElementById('authorsPage').style.display = 'none';
    }

    function shareObservation() {
      try {
        window.open('https://t.me/quantportrat', '_blank');
        alert(language === 'ru' ? 'Ссылка открыта в новой вкладке.' : 'Link opened in a new tab.');
      } catch (e) {
        console.error('Ошибка при открытии ссылки:', e);
        alert(language === 'ru' ? 'Не удалось открыть ссылку. Проверьте настройки браузера.' : 'Failed to open link. Check browser settings.');
      }
    }

    function goToArchive() {
      try {
        window.open('https://t.me/quantportrat', '_blank');
        alert(language === 'ru' ? 'Ссылка открыта в новой вкладке.' : 'Link opened in a new tab.');
      } catch (e) {
        console.error('Ошибка при открытии ссылки:', e);
        alert(language === 'ru' ? 'Не удалось открыть ссылку. Проверьте настройки браузера.' : 'Failed to open link. Check browser settings.');
      }
    }

    function fixObservation() {
      if (!isPaused) {
        isPaused = true;
        noLoop();
        document.getElementById('saveButton').style.display = 'block';
        console.log('Шаг 6: Пауза, saveButton отображается');
        saveCurrentState();
      }
    }

    function returnToUncertainty() {
      const currentStepElement = document.querySelector(`#step${currentStep}`);
      if (currentStepElement) currentStepElement.classList.remove('active');
      currentStep = 5;
      const targetStepElement = document.querySelector(`#step${currentStep}`);
      targetStepElement.classList.add('active');
      document.getElementById('backButton').style.display = 'block';
      document.getElementById('continueButton').style.display = 'block';
      if (isCanvasReady) {
        showCanvas('canvasContainer5');
        showUserImage();
        formationPhase = 0;
        if (!isPaused) loop();
      }
      typeText(`typewriter${currentStep}`, translations[`step${currentStep}`][language], 600, 70, 35);
    }

    function saveCurrentState() {
      try {
        if (!canvas) {
          alert(language === 'ru' ? 'Canvas не найден. Убедитесь, что изображение отображается.' : 'Canvas not found. Ensure the image is displayed.');
          return;
        }
        const dataURL = canvas.elt.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = 'quantum-portrait.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        alert(language === 'ru' ? 'Изображение сохранено как quantum-portrait.png' : 'Image saved as quantum-portrait.png');
      } catch (e) {
        console.error('Ошибка сохранения изображения:', e);
        alert(language === 'ru' ? 'Не удалось сохранить изображение. Попробуйте загрузить сайт на хостинг.' : 'Failed to save image. Try hosting the site.');
      }
    }

    // Эффект присутствия других наблюдателей (заглушка)
    let otherCursors = [];
    function simulateOtherCursors() {
      if (currentStep === 5) {
        if (random() < 0.02) {
          const cursor = document.createElement('div');
          cursor.className = 'other-cursor';
          cursor.style.left = `${random(windowWidth)}px`;
          cursor.style.top = `${random(windowHeight)}px`;
          document.body.appendChild(cursor);
          otherCursors.push(cursor);
          setTimeout(() => {
            cursor.remove();
            otherCursors = otherCursors.filter(c => c !== cursor);
          }, 3000);
        }
      }
    }

    let noiseScale = 0.02;
    let brightColors = [[255, 0, 0], [255, 105, 180], [0, 0, 255], [0, 255, 0], [255, 255, 0]];
    let mouseInfluenceRadius = 100;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let wavePhase = 0;

    function setup() {
      canvas = createCanvas(windowWidth * 0.9, windowHeight * 0.6);
      canvas.parent('canvasContainer5');
      pixelDensity(1);
      frameRate(30);
      noLoop();
      canvas.elt.style.display = 'none';

      canvas.elt.addEventListener('click', function() {
        if (currentStep === 6 && !isPaused) {
          fixObservation();
        }
      });

      canvas.elt.addEventListener('touchmove', function(e) {
        e.preventDefault();
        const touch = e.touches[0];
        mouseX = touch.clientX - canvas.elt.offsetLeft;
        mouseY = touch.clientY - canvas.elt.offsetTop;
      });

      window.addEventListener('resize', () => {
        resizeCanvas(windowWidth * 0.9, windowHeight * 0.6);
      });

      lastMouseX = mouseX;
      lastMouseY = mouseY;
      isCanvasReady = true;
      console.log('setup: Канва создана и готова');
    }

    function draw() {
      simulateOtherCursors();
      if (!img || !img.width || quantumStates.length === 0) {
        if (img && img.width) {
          let centerX = width / 2;
          let centerY = height / 2;
          let scaleFactor = min(width, height) / 512;
          let gridSize = Math.max(4 / scaleFactor, 1);
          for (let y = 0; y < 256; y += gridSize) {
            for (let x = 0; x < 256; x += gridSize) {
              let pixelX = constrain(x, 0, 255);
              let pixelY = constrain(y, 0, 255);
              let col = img.get(pixelX, pixelY);
              let brightnessVal = brightness(col);
              if (brightnessVal > 20) {
                let size = random(4, 8) * scaleFactor;
                let shapeType = floor(random(4));
                let distFromCenter = dist(x, y, 128, 128);
                let densityFactor = map(distFromCenter, 0, 128, 1, 0.3);
                if (random() < densityFactor && particles.length < 2000) {
                  particles.push({
                    x: centerX - 128 * scaleFactor + x * scaleFactor,
                    y: centerY - 128 * scaleFactor + y * scaleFactor,
                    baseX: centerX - 128 * scaleFactor + x * scaleFactor,
                    baseY: centerY - 128 * scaleFactor + y * scaleFactor,
                    offsetX: 0,
                    offsetY: 0,
                    size: size,
                    phase: random(TWO_PI),
                    entangledWith: null,
                    gridX: x,
                    gridY: y,
                    shapeType: shapeType,
                    wavePhase: 0,
                    waveInfluence: 0,
                    baseColor: [red(col), green(col), blue(col)],
                    tunneled: false,
                    tunnelTargetX: 0,
                    tunnelTargetY: 0,
                    tunnelReturnSpeed: 0.02
                  });
                }
              }
            }
          }

          img.loadPixels();
          for (let i = 0; i < particles.length; i++) {
            let particle = particles[i];
            let pixelX = constrain(Math.floor((particle.baseX - (centerX - 128 * scaleFactor)) / scaleFactor), 0, img.width - 1);
            let pixelY = constrain(Math.floor((particle.baseY - (centerY - 128 * scaleFactor)) / scaleFactor), 0, img.height - 1);
            let col = img.get(pixelX, pixelY);
            let entangledIndex = null;
            if (random() < 0.3) {
              let potentialPartners = particles.filter((p, idx) => idx !== i && !p.entangledWith);
              if (potentialPartners.length > 0) {
                let partner = random(potentialPartners);
                entangledIndex = particles.indexOf(partner);
                partner.entangledWith = i;
              }
            }
            quantumStates[i] = {
              r: red(col),
              g: green(col),
              b: blue(col),
              a: alpha(col),
              baseR: red(col),
              baseG: green(col),
              baseB: blue(col),
              superpositionStates: [
                { r: red(col) + random(-30, 30), g: green(col) + random(-30, 30), b: blue(col) + random(-30, 30) },
                { r: red(col) + random(-30, 30), g: green(col) + random(-30, 30), b: blue(col) + random(-30, 30) }
              ],
              collapsed: false,
              entangledWith: entangledIndex,
              phase: random(TWO_PI),
              amplitude: random(30, 60) * scaleFactor,
              isLips: (pixelY > img.height * 0.47 && pixelY < img.height * 0.55 && pixelX > img.width * 0.35 && pixelX < img.width * 0.65),
              isEyes: ((pixelY > img.height * 0.31 && pixelY < img.height * 0.39) && ((pixelX > img.width * 0.31 && pixelX < img.width * 0.43) || (pixelX > img.width * 0.57 && pixelX < img.width * 0.69))),
              isHair: (pixelY < img.height * 0.31),
              brightColor: null
            };
          }
        }
        return;
      }

      frame += 1;
      if (formationPhase < 1) {
        formationPhase += 0.01;
      }

      background(0);

      let ghostAlpha = 150 * (1 - formationPhase * 0.6);
      tint(255, ghostAlpha);
      image(img, width / 2 - 128 * (min(width, height) / 512), height / 2 - 128 * (min(width, height) / 512), 256 * (min(width, height) / 512), 256 * (min(width, height) / 512));
      noTint();

      let mouseSpeed = dist(mouseX, mouseY, lastMouseX, lastMouseY);
      if (mouseSpeed > 0 && !isPaused) wavePhase += 0.1;
      lastMouseX = mouseX;
      lastMouseY = mouseY;

      for (let i = 0; i < particles.length; i++) {
        let particle = particles[i];
        let state = quantumStates[i];
        if (state.entangledWith !== null && formationPhase >= 1) {
          let entangledParticle = particles[state.entangledWith];
          let alpha = 100 * (0.5 + 0.5 * sin(frame * 0.03));
          stroke(255, alpha);
          strokeWeight(0.5);
          noFill();
          beginShape();
          for (let t = 0; t <= 1; t += 0.05) {
            let x = lerp(particle.x + particle.offsetX, entangledParticle.x + entangledParticle.offsetX, t);
            let y = lerp(particle.y + particle.offsetY, entangledParticle.y + entangledParticle.offsetY, t);
            let offset = noise(x * 0.01, y * 0.01, frame * 0.02) * 10;
            vertex(x + offset, y + offset);
          }
          endShape();
        }
      }

      for (let i = 0; i < particles.length; i++) {
        let particle = particles[i];
        let state = quantumStates[i];
        let speedFactor = 1.0;
        if (state.isEyes) speedFactor = 1.5;
        if (state.isLips) speedFactor = 1.2;
        if (state.isHair) speedFactor = 0.8;

        let d = dist(mouseX, mouseY, particle.x + particle.offsetX, particle.y + particle.offsetY);
        if (d < mouseInfluenceRadius && !isPaused) {
          particle.waveInfluence = map(d, 0, mouseInfluenceRadius, 1, 0);
          particle.wavePhase = wavePhase - d * 0.05;
        } else {
          particle.waveInfluence = 0;
        }

        let noiseVal = noise(particle.baseX * noiseScale, particle.baseY * noiseScale, frame * 0.01);
        let distFromCenter = dist(particle.baseX, particle.baseY, width / 2, height / 2);
        let maxAmplitude = map(distFromCenter, 0, 128 * (min(width, height) / 512), 20, 60);
        let positionUncertainty = map(d, 0, mouseInfluenceRadius, 0.1, 1);
        let baseOffsetX = sin(state.phase) * state.amplitude * noiseVal * speedFactor * (maxAmplitude / 150) * positionUncertainty * formationPhase;
        let baseOffsetY = cos(state.phase) * state.amplitude * noiseVal * speedFactor * (maxAmplitude / 150) * positionUncertainty * formationPhase;

        let waveOffsetX = 0;
        let waveOffsetY = 0;
        if (particle.waveInfluence > 0 && !isPaused) {
          waveOffsetX = sin(particle.wavePhase) * 30 * particle.waveInfluence * formationPhase;
          waveOffsetY = cos(particle.wavePhase) * 30 * particle.waveInfluence * formationPhase;
        }

        let centerDist = dist(particle.x, particle.y, width / 2, height / 2);
        if (!particle.tunneled && centerDist > 128 * (min(width, height) / 512) && random() < 0.01 && !isPaused && formationPhase >= 1) {
          particle.tunneled = true;
          particle.tunnelTargetX = random(width);
          particle.tunnelTargetY = random(height);
        }
        if (particle.tunneled) {
          particle.offsetX = lerp(particle.offsetX, particle.tunnelTargetX - particle.x, particle.tunnelReturnSpeed);
          particle.offsetY = lerp(particle.offsetY, particle.tunnelTargetY - particle.y, particle.tunnelReturnSpeed);
          if (dist(particle.x + particle.offsetX, particle.y + particle.offsetY, particle.tunnelTargetX, particle.tunnelTargetY) < 10) {
            particle.tunneled = false;
          }
        }

        particle.offsetX = baseOffsetX + waveOffsetX;
        particle.offsetY = baseOffsetY + waveOffsetY;

        let dx = particle.baseX - (particle.x + particle.offsetX);
        particle.x += dx * 0.03;
        particle.offsetX += dx * 0.03;
        let dy = particle.baseY - (particle.y + particle.offsetY);
        particle.y += dy * 0.03;
        particle.offsetY += dy * 0.03;

        state.phase += 0.02 * speedFactor;

        let colorUncertainty = map(d, 0, mouseInfluenceRadius, 0, 0.05);
        if (random() < colorUncertainty && !isPaused && formationPhase >= 1) {
          if (random() < 0.5 && !state.collapsed) {
            let newState = random(state.superpositionStates);
            state.r = newState.r;
            state.g = newState.g;
            state.b = newState.b;
          } else if (random() < 0.01 && !state.brightColor) {
            state.brightColor = random(brightColors);
          }
        } else {
          state.r = state.baseR;
          state.g = state.baseG;
          state.b = state.baseB;
          state.brightColor = null;
        }

        if (d < 50 && !state.collapsed && !isPaused && formationPhase >= 1) {
          state.collapsed = true;
          let chosenState = random(state.superpositionStates);
          state.r = chosenState.r;
          state.g = chosenState.g;
          state.b = chosenState.b;

          if (state.entangledWith !== null) {
            let entangledState = quantumStates[state.entangledWith];
            if (!entangledState.collapsed) {
              entangledState.collapsed = true;
              entangledState.r = chosenState.r;
              entangledState.g = chosenState.g;
              entangledState.b = chosenState.b;
            }
          }
        }

        if (!state.collapsed) {
          let t = 0.5 + 0.5 * sin(frame * 0.05 + state.phase);
          state.r = lerp(state.superpositionStates[0].r, state.superpositionStates[1].r, t) * (1 - colorUncertainty) + state.baseR * colorUncertainty;
          state.g = lerp(state.superpositionStates[0].g, state.superpositionStates[1].g, t) * (1 - colorUncertainty) + state.baseG * colorUncertainty;
          state.b = lerp(state.superpositionStates[0].b, state.superpositionStates[1].b, t) * (1 - colorUncertainty) + state.baseB * colorUncertainty;
        }

        push();
        translate(particle.x + particle.offsetX, particle.y + particle.offsetY);
        noStroke();
        let alpha = state.a * (0.5 + 0.5 * sin(frame * 0.05 + state.phase)) * formationPhase;
        if (state.brightColor) {
          fill(state.brightColor[0], state.brightColor[1], state.brightColor[2], alpha * 0.8);
        } else {
          fill(state.r, state.g, state.b, alpha * 0.8);
        }

        let uncertainty = map(d, 0, mouseInfluenceRadius, 0, 1);
        if (random() < uncertainty * 0.02 && !isPaused && formationPhase >= 1) particle.shapeType = floor(random(4));

        switch (particle.shapeType) {
          case 0:
            beginShape();
            for (let angle = 0; angle < TWO_PI; angle += 0.1) {
              let r = particle.size * (1 + 0.3 * noise(particle.x * 0.01, particle.y * 0.01, frame * 0.02)) * formationPhase;
              let x = r * cos(angle);
              let y = r * sin(angle);
              vertex(x, y);
            }
            endShape(CLOSE);
            break;
          case 1:
            rect(-particle.size / 2 * formationPhase, -particle.size / 2 * formationPhase, particle.size * formationPhase, particle.size * formationPhase);
            break;
          case 2:
            triangle(-particle.size / 2 * formationPhase, particle.size / 2 * formationPhase, particle.size / 2 * formationPhase, particle.size / 2 * formationPhase, 0, -particle.size / 2 * formationPhase);
            break;
          case 3:
            let shear = particle.size * 0.3 * formationPhase;
            quad(-particle.size / 2 * formationPhase, -particle.size / 2 * formationPhase, particle.size / 2 * formationPhase - shear, -particle.size / 2 * formationPhase, particle.size / 2 * formationPhase, particle.size / 2 * formationPhase, -particle.size / 2 * formationPhase + shear, particle.size / 2 * formationPhase);
            break;
        }
        pop();
      }
    }
  </script>
</body>
</html>